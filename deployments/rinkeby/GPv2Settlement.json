{
  "address": "0x471B773019E5023DB37f33A774e5f4CC9C50CaBC",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract GPv2Authentication",
          "name": "authenticator_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "contract IERC20",
          "name": "sellToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "contract IERC20",
          "name": "buyToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "sellAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "buyAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "feeAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "orderUid",
          "type": "bytes"
        }
      ],
      "name": "Trade",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "allowanceManager",
      "outputs": [
        {
          "internalType": "contract GPv2AllowanceManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "domainSeparator",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "filledAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "orderUid",
          "type": "bytes"
        }
      ],
      "name": "invalidateOrder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "clearingPrices",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "encodedTrades",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "encodedInteractions",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "encodedOrderRefunds",
          "type": "bytes"
        }
      ],
      "name": "settle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0xfc3066fa7632f9ce8a0f258ce3d5886d9f2083c47ca27c17a5a0db466f419a53",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x42b7e89374BcEAb213c699488f667c7a9144C28b",
    "contractAddress": null,
    "transactionIndex": 6,
    "gasUsed": "2072478",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x484bd45724ac0a8d098c64dab36277f2482f4443aeeaa945e04a1502648a93b5",
    "transactionHash": "0xfc3066fa7632f9ce8a0f258ce3d5886d9f2083c47ca27c17a5a0db466f419a53",
    "logs": [],
    "blockNumber": 7852856,
    "cumulativeGasUsed": "2435478",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x091c1CDe12584225dce0fc2a5b3F50bC04D470CC"
  ],
  "solcInputHash": "0df6fb089edd5bf6d0d6236b23739093",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract GPv2Authentication\",\"name\":\"authenticator_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"orderUid\",\"type\":\"bytes\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowanceManager\",\"outputs\":[{\"internalType\":\"contract GPv2AllowanceManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"filledAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"orderUid\",\"type\":\"bytes\"}],\"name\":\"invalidateOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"clearingPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"encodedTrades\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"encodedInteractions\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"encodedOrderRefunds\",\"type\":\"bytes\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"Gnosis Developers\",\"events\":{\"Trade(address,address,address,uint256,uint256,uint256,bytes)\":{\"details\":\"Event emitted for each executed trade.\"}},\"kind\":\"dev\",\"methods\":{\"invalidateOrder(bytes)\":{\"details\":\"Invalidate onchain an order that has been signed offline.\",\"params\":{\"orderUid\":\"The unique identifier of the order that is to be made invalid after calling this function. The user that created the order must be the the sender of this message. See [`extractOrderUidParams`] for details on orderUid.\"}},\"settle(address[],uint256[],bytes,bytes,bytes)\":{\"details\":\"Settle the specified orders at a clearing price. Note that it is the responsibility of the caller to ensure that all GPv2 invariants are upheld for the input settlement, otherwise this call will revert. Namely: - The fee factor cannot lead to fees > 0.1% - All orders are valid and signed - Accounts have sufficient balance and approval. - Settlement contract has sufficient balance to execute trades. Note   this implies that the accumulated fees held in the contract can also   be used for settlement. This is OK since:   - Solvers need to be authorized   - Misbehaving solvers will be slashed for abusing accumulated fees for     settlement   - Critically, user orders are entirely protected Note that some parameters are encoded as packed bytes in order to save calldata gas. For more information on encoding format consult the [`GPv2Encoding`] library.\",\"params\":{\"clearingPrices\":\"An array of clearing prices where the `i`-th price is for the `i`-th token in the [`tokens`] array.\",\"encodedInteractions\":\"Encoded smart contract interactions.\",\"encodedOrderRefunds\":\"Encoded order refunds for clearing storage related to invalid orders.\",\"encodedTrades\":\"Encoded trades for signed EOA orders.\",\"tokens\":\"An array of ERC20 tokens to be traded in the settlement. Orders and interactions encode tokens as indices into this array.\"}}},\"stateVariables\":{\"BPS_BASE\":{\"details\":\"The number of basis points to make up 100%.\"},\"DOMAIN_NAME\":{\"details\":\"The EIP-712 domain name used for computing the domain separator.\"},\"DOMAIN_TYPE_HASH\":{\"details\":\"The EIP-712 domain type hash used for computing the domain separator.\"},\"DOMAIN_VERSION\":{\"details\":\"The EIP-712 domain version used for computing the domain separator.\"},\"allowanceManager\":{\"details\":\"The allowance manager which has access to EOA order funds. This contract is created during deployment\"},\"authenticator\":{\"details\":\"The authenticator is used to determine who can call the settle function. That is, only authorised solvers have the ability to invoke settlements. Any valid authenticator implements an isSolver method called by the onlySolver modifier below.\"},\"domainSeparator\":{\"details\":\"The domain separator used for signing orders that gets mixed in making signatures for different domains incompatible. This domain separator is computed following the EIP-712 standard and has replay protection mixed in so that signed orders are only valid for specific GPv2 contracts.\"},\"filledAmount\":{\"details\":\"Map each user order by UID to the amount that has been filled so far. If this amount is larger than or equal to the amount traded in the order (amount sold for sell orders, amount bought for buy orders) then the order cannot be traded anymore. If the order is fill or kill, then this value is only used to determine whether the order has already been executed.\"}},\"title\":\"Gnosis Protocol v2 Settlement Contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/GPv2Settlement.sol\":\"GPv2Settlement\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x3b21f2c8d626de3b9925ae33e972d8bf5c8b1bffb3f4ee94daeed7d0679036e6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x5f02220344881ce43204ae4a6281145a67bc52c2bb1290a791857df3d19d78f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf12dfbe97e6276980b83d2830bb0eb75e0cf4f3e626c2471137f82158ae6a0fc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa6a15ddddcbf29d2922a1e0d4151b5d2d33da24b93cc9ebc12390e0d855532f8\",\"license\":\"MIT\"},\"src/contracts/GPv2AllowanceManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./libraries/GPv2TradeExecution.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Allowance Manager Contract\\n/// @author Gnosis Developers\\ncontract GPv2AllowanceManager {\\n    using GPv2TradeExecution for GPv2TradeExecution.Data;\\n\\n    /// @dev The recipient of all transfers made by the allowance manager. The\\n    /// recipient is set at creation time and cannot change.\\n    address private immutable recipient;\\n\\n    constructor() {\\n        recipient = msg.sender;\\n    }\\n\\n    /// @dev Modifier that ensures that a function can only be called by the\\n    /// recipient of this contract.\\n    modifier onlyRecipient {\\n        require(msg.sender == recipient, \\\"GPv2: not allowance recipient\\\");\\n        _;\\n    }\\n\\n    /// @dev Transfers all sell amounts for the executed trades from their\\n    /// owners to the caller.\\n    ///\\n    /// This function reverts if:\\n    /// - The caller is not the recipient of the allowance manager\\n    /// - Any ERC20 transfer fails\\n    ///\\n    /// @param trades The executed trades whose sell amounts need to be\\n    /// transferred in.\\n    function transferIn(GPv2TradeExecution.Data[] calldata trades)\\n        external\\n        onlyRecipient\\n    {\\n        for (uint256 i = 0; i < trades.length; i++) {\\n            GPv2TradeExecution.transferSellAmountToRecipient(\\n                trades[i],\\n                msg.sender\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x01abf5a8393fdf48528b05b105ea0026986cd3572411d4d416b0204a37b7f6cf\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/GPv2Settlement.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./GPv2AllowanceManager.sol\\\";\\nimport \\\"./interfaces/GPv2Authentication.sol\\\";\\nimport \\\"./libraries/GPv2Encoding.sol\\\";\\nimport \\\"./libraries/GPv2TradeExecution.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Settlement Contract\\n/// @author Gnosis Developers\\ncontract GPv2Settlement {\\n    using GPv2Encoding for bytes;\\n    using GPv2TradeExecution for GPv2TradeExecution.Data;\\n    using SafeMath for uint256;\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 private constant DOMAIN_TYPE_HASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 private constant DOMAIN_NAME = keccak256(\\\"Gnosis Protocol\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 private constant DOMAIN_VERSION = keccak256(\\\"v2\\\");\\n\\n    /// @dev The number of basis points to make up 100%.\\n    uint256 private constant BPS_BASE = 10000;\\n\\n    /// @dev The domain separator used for signing orders that gets mixed in\\n    /// making signatures for different domains incompatible. This domain\\n    /// separator is computed following the EIP-712 standard and has replay\\n    /// protection mixed in so that signed orders are only valid for specific\\n    /// GPv2 contracts.\\n    bytes32 public immutable domainSeparator;\\n\\n    /// @dev The authenticator is used to determine who can call the settle function.\\n    /// That is, only authorised solvers have the ability to invoke settlements.\\n    /// Any valid authenticator implements an isSolver method called by the onlySolver\\n    /// modifier below.\\n    GPv2Authentication private immutable authenticator;\\n\\n    /// @dev The allowance manager which has access to EOA order funds. This\\n    /// contract is created during deployment\\n    GPv2AllowanceManager public immutable allowanceManager;\\n\\n    /// @dev Map each user order by UID to the amount that has been filled so\\n    /// far. If this amount is larger than or equal to the amount traded in the\\n    /// order (amount sold for sell orders, amount bought for buy orders) then\\n    /// the order cannot be traded anymore. If the order is fill or kill, then\\n    /// this value is only used to determine whether the order has already been\\n    /// executed.\\n    mapping(bytes => uint256) public filledAmount;\\n\\n    /// @dev Event emitted for each executed trade.\\n    event Trade(\\n        address indexed owner,\\n        IERC20 sellToken,\\n        IERC20 buyToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount,\\n        uint256 feeAmount,\\n        bytes orderUid\\n    );\\n\\n    constructor(GPv2Authentication authenticator_) {\\n        authenticator = authenticator_;\\n\\n        // NOTE: Currently, the only way to get the chain ID in solidity is\\n        // using assembly.\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPE_HASH,\\n                DOMAIN_NAME,\\n                DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n        allowanceManager = new GPv2AllowanceManager();\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {\\n        // NOTE: Include an empty receive function so that the settlement\\n        // contract can receive Ether from contract interactions.\\n    }\\n\\n    /// @dev This modifier is called by settle function to block any non-listed\\n    /// senders from settling batches.\\n    modifier onlySolver {\\n        require(authenticator.isSolver(msg.sender), \\\"GPv2: not a solver\\\");\\n        _;\\n    }\\n\\n    /// @dev Settle the specified orders at a clearing price. Note that it is\\n    /// the responsibility of the caller to ensure that all GPv2 invariants are\\n    /// upheld for the input settlement, otherwise this call will revert.\\n    /// Namely:\\n    /// - The fee factor cannot lead to fees > 0.1%\\n    /// - All orders are valid and signed\\n    /// - Accounts have sufficient balance and approval.\\n    /// - Settlement contract has sufficient balance to execute trades. Note\\n    ///   this implies that the accumulated fees held in the contract can also\\n    ///   be used for settlement. This is OK since:\\n    ///   - Solvers need to be authorized\\n    ///   - Misbehaving solvers will be slashed for abusing accumulated fees for\\n    ///     settlement\\n    ///   - Critically, user orders are entirely protected\\n    ///\\n    /// Note that some parameters are encoded as packed bytes in order to save\\n    /// calldata gas. For more information on encoding format consult the\\n    /// [`GPv2Encoding`] library.\\n    ///\\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\\n    /// Orders and interactions encode tokens as indices into this array.\\n    /// @param clearingPrices An array of clearing prices where the `i`-th price\\n    /// is for the `i`-th token in the [`tokens`] array.\\n    /// @param encodedTrades Encoded trades for signed EOA orders.\\n    /// @param encodedInteractions Encoded smart contract interactions.\\n    /// @param encodedOrderRefunds Encoded order refunds for clearing storage\\n    /// related to invalid orders.\\n    function settle(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        bytes calldata encodedTrades,\\n        bytes calldata encodedInteractions,\\n        bytes calldata encodedOrderRefunds\\n    ) external onlySolver {\\n        GPv2TradeExecution.Data[] memory executedTrades =\\n            computeTradeExecutions(tokens, clearingPrices, encodedTrades);\\n        allowanceManager.transferIn(executedTrades);\\n\\n        executeInteractions(encodedInteractions);\\n\\n        transferOut(executedTrades);\\n\\n        require(encodedOrderRefunds.length == 0, \\\"not yet implemented\\\");\\n    }\\n\\n    /// @dev Invalidate onchain an order that has been signed offline.\\n    /// @param orderUid The unique identifier of the order that is to be made\\n    /// invalid after calling this function. The user that created the order\\n    /// must be the the sender of this message. See [`extractOrderUidParams`]\\n    /// for details on orderUid.\\n    function invalidateOrder(bytes calldata orderUid) external {\\n        (, address owner, ) = orderUid.extractOrderUidParams();\\n        require(owner == msg.sender, \\\"GPv2: caller does not own order\\\");\\n        filledAmount[orderUid] = uint256(-1);\\n    }\\n\\n    /// @dev Process all trades for EOA orders one at a time returning the\\n    /// computed net in and out transfers for the trades.\\n    ///\\n    /// This method reverts if processing of any single trade fails. See\\n    /// [`processOrder`] for more details.\\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\\n    /// @param clearingPrices An array of token clearing prices.\\n    /// @param encodedTrades Encoded trades for signed EOA orders.\\n    /// @return executedTrades Array of executed trades.\\n    function computeTradeExecutions(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata clearingPrices,\\n        bytes calldata encodedTrades\\n    ) internal returns (GPv2TradeExecution.Data[] memory executedTrades) {\\n        uint256 tradeCount = encodedTrades.tradeCount();\\n        executedTrades = new GPv2TradeExecution.Data[](tradeCount);\\n\\n        GPv2Encoding.Trade memory trade;\\n        for (uint256 i = 0; i < tradeCount; i++) {\\n            encodedTrades.tradeAtIndex(i).decodeTrade(\\n                domainSeparator,\\n                tokens,\\n                trade\\n            );\\n            computeTradeExecution(\\n                trade,\\n                clearingPrices[trade.sellTokenIndex],\\n                clearingPrices[trade.buyTokenIndex],\\n                executedTrades[i]\\n            );\\n        }\\n    }\\n\\n    /// @dev Compute the in and out transfer amounts for a single EOA order\\n    /// trade. This function reverts if:\\n    /// - The order has expired\\n    /// - The order's limit price is not respected.\\n    ///\\n    /// @param trade The trade to process.\\n    /// @param sellPrice The price of the order's sell token.\\n    /// @param buyPrice The price of the order's buy token.\\n    /// @param executedTrade Memory location for computed executed trade data.\\n    function computeTradeExecution(\\n        GPv2Encoding.Trade memory trade,\\n        uint256 sellPrice,\\n        uint256 buyPrice,\\n        GPv2TradeExecution.Data memory executedTrade\\n    ) internal {\\n        GPv2Encoding.Order memory order = trade.order;\\n\\n        // solhint-disable-next-line not-rely-on-time\\n        require(order.validTo >= block.timestamp, \\\"GPv2: order expired\\\");\\n\\n        executedTrade.owner = trade.owner;\\n        executedTrade.sellToken = order.sellToken;\\n        executedTrade.buyToken = order.buyToken;\\n\\n        // NOTE: The following computation is derived from the equation:\\n        // ```\\n        // amount_x * price_x = amount_y * price_y\\n        // ```\\n        // Intuitively, if a chocolate bar is 0,50\\u20ac and a beer is 4\\u20ac, 1 beer\\n        // is roughly worth 8 chocolate bars (`1 * 4 = 8 * 0.5`). From this\\n        // equation, we can derive:\\n        // - The limit price for selling `x` and buying `y` is respected iff\\n        // ```\\n        // limit_x * price_x >= limit_y * price_y\\n        // ```\\n        // - The executed amount of token `y` given some amount of `x` and\\n        //   clearing prices is:\\n        // ```\\n        // amount_y = amount_x * price_x / price_y\\n        // ```\\n\\n        require(\\n            order.sellAmount.mul(sellPrice) >= order.buyAmount.mul(buyPrice),\\n            \\\"GPv2: limit price not respected\\\"\\n        );\\n\\n        uint256 executedSellAmount;\\n        uint256 executedBuyAmount;\\n        uint256 executedFeeAmount;\\n        uint256 currentFilledAmount;\\n\\n        // NOTE: Don't use `SafeMath.div` or `SafeMath.sub` anywhere here as it\\n        // allocates a string even if it does not revert. Additionally, `div`\\n        // only checks that the divisor is non-zero and `revert`s in that case\\n        // instead of consuming all of the remaining transaction gas when\\n        // dividing by zero, so no extra checks are needed for those operations.\\n\\n        if (order.kind == GPv2Encoding.ORDER_KIND_SELL) {\\n            if (order.partiallyFillable) {\\n                executedSellAmount = trade.executedAmount;\\n                executedFeeAmount =\\n                    order.feeAmount.mul(executedSellAmount) /\\n                    order.sellAmount;\\n            } else {\\n                executedSellAmount = order.sellAmount;\\n                executedFeeAmount = order.feeAmount;\\n            }\\n\\n            executedBuyAmount = executedSellAmount.mul(sellPrice) / buyPrice;\\n\\n            currentFilledAmount = filledAmount[trade.orderUid].add(\\n                executedSellAmount\\n            );\\n            require(\\n                currentFilledAmount <= order.sellAmount,\\n                \\\"GPv2: order filled\\\"\\n            );\\n        } else {\\n            if (order.partiallyFillable) {\\n                executedBuyAmount = trade.executedAmount;\\n                executedFeeAmount =\\n                    order.feeAmount.mul(executedBuyAmount) /\\n                    order.buyAmount;\\n            } else {\\n                executedBuyAmount = order.buyAmount;\\n                executedFeeAmount = order.feeAmount;\\n            }\\n\\n            executedSellAmount = executedBuyAmount.mul(buyPrice) / sellPrice;\\n\\n            currentFilledAmount = filledAmount[trade.orderUid].add(\\n                executedBuyAmount\\n            );\\n            require(\\n                currentFilledAmount <= order.buyAmount,\\n                \\\"GPv2: order filled\\\"\\n            );\\n        }\\n\\n        require(trade.feeDiscount <= BPS_BASE, \\\"GPv2: invalid fee discount\\\");\\n        executedFeeAmount =\\n            executedFeeAmount.mul(BPS_BASE - trade.feeDiscount) /\\n            BPS_BASE;\\n\\n        executedTrade.sellAmount = executedSellAmount.add(executedFeeAmount);\\n        executedTrade.buyAmount = executedBuyAmount;\\n\\n        filledAmount[trade.orderUid] = currentFilledAmount;\\n        emit Trade(\\n            executedTrade.owner,\\n            executedTrade.sellToken,\\n            executedTrade.buyToken,\\n            executedTrade.sellAmount,\\n            executedTrade.buyAmount,\\n            executedFeeAmount,\\n            trade.orderUid\\n        );\\n    }\\n\\n    /// @dev Execute a list of arbitrary contract calls from this contract.\\n    /// @param encodedInteractions The encoded list of interactions that will be\\n    /// executed.\\n    function executeInteractions(bytes calldata encodedInteractions) internal {\\n        // Note: at every decoding step, the content of this variable is\\n        // replaced with the latest decoded interaction.\\n        GPv2Encoding.Interaction memory interaction;\\n\\n        bytes calldata remainingEncodedInteractions = encodedInteractions;\\n        while (remainingEncodedInteractions.length != 0) {\\n            remainingEncodedInteractions = remainingEncodedInteractions\\n                .decodeInteraction(interaction);\\n            executeInteraction(interaction);\\n        }\\n    }\\n\\n    /// @dev Allows settlement function to make arbitrary contract executions.\\n    /// @param interaction contains address and calldata of the contract interaction.\\n    function executeInteraction(GPv2Encoding.Interaction memory interaction)\\n        internal\\n    {\\n        // To prevent possible attack on user funds, we explicitly disable\\n        // interactions with AllowanceManager contract.\\n        require(\\n            interaction.target != address(allowanceManager),\\n            \\\"GPv2: forbidden interaction\\\"\\n        );\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory response) =\\n            (interaction.target).call(interaction.callData);\\n        // solhint-enable avoid-low-level-calls\\n\\n        // TODO - concatenate the following reponse \\\"GPv2: Failed Interaction\\\"\\n        // This is the topic of https://github.com/gnosis/gp-v2-contracts/issues/240\\n        if (!success) {\\n            // Assembly used to revert with correctly encoded error message.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                revert(add(response, 0x20), mload(response))\\n            }\\n        }\\n    }\\n\\n    /// @dev Transfers all buy amounts for the executed trades from the\\n    /// settlement contract to the order owners. This function reverts if any of\\n    /// the ERC20 operations fail.\\n    ///\\n    /// @param trades The executed trades whose buy amounts need to be\\n    /// transferred out.\\n    function transferOut(GPv2TradeExecution.Data[] memory trades) internal {\\n        for (uint256 i = 0; i < trades.length; i++) {\\n            trades[i].transferBuyAmountToOwner();\\n        }\\n    }\\n\\n    /// @dev Frees the storage for an order that is no longer valid granting a\\n    /// gas refund.\\n    ///\\n    /// This method reverts if the order is still valid.\\n    ///\\n    /// @param orderUid The unique identifier of the order to free.\\n    function freeOrderStorage(bytes calldata orderUid) internal {\\n        (, , uint32 validTo) = orderUid.extractOrderUidParams();\\n        // solhint-disable-next-line not-rely-on-time\\n        require(validTo < block.timestamp, \\\"GPv2: order still valid\\\");\\n        filledAmount[orderUid] = 0;\\n    }\\n}\\n\",\"keccak256\":\"0x2c8783c27462018f5d283fab9890c6c7ec15a1deb8e5d8e0f7bbb50aa00e2d10\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/interfaces/GPv2Authentication.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.7.6;\\n\\n/// @title Gnosis Protocol v2 Authentication Interface\\n/// @author Gnosis Developers\\ninterface GPv2Authentication {\\n    /// @dev determines whether the provided address is an authenticated solver.\\n    /// @param prospectiveSolver the address of prospective solver.\\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\\n    function isSolver(address prospectiveSolver) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xffbd3b9ca8cb5b86c3d7f7ce706755dd6acdc86ef9acefcb5bae375ea50628e3\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/libraries/GPv2Encoding.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Encoding Library.\\n/// @author Gnosis Developers\\nlibrary GPv2Encoding {\\n    /// @dev A struct representing an order containing all order parameters that\\n    /// are signed by a user for submitting to GP.\\n    struct Order {\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n        uint32 validTo;\\n        uint32 appData;\\n        uint256 feeAmount;\\n        bytes32 kind;\\n        bool partiallyFillable;\\n    }\\n\\n    /// @dev The marker value for a sell order for computing the order struct\\n    /// hash. This allows the EIP-712 compatible wallets to display a\\n    /// descriptive string for the order kind (instead of 0 or 1).\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"sell\\\")\\n    /// ```\\n    bytes32 internal constant ORDER_KIND_SELL =\\n        hex\\\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\\\";\\n\\n    /// @dev The OrderKind marker value for a buy order for computing the order\\n    /// struct hash.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\\"buy\\\")\\n    /// ```\\n    bytes32 internal constant ORDER_KIND_BUY =\\n        hex\\\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\\\";\\n\\n    /// @dev The order EIP-712 type hash for the [`Order`] struct.\\n    ///\\n    /// This value is pre-computed from the following expression:\\n    /// ```\\n    /// keccak256(\\n    ///     \\\"Order(\\\" +\\n    ///         \\\"address sellToken,\\\" +\\n    ///         \\\"address buyToken,\\\" +\\n    ///         \\\"uint256 sellAmount,\\\" +\\n    ///         \\\"uint256 buyAmount,\\\" +\\n    ///         \\\"uint32 validTo,\\\" +\\n    ///         \\\"uint32 appData,\\\" +\\n    ///         \\\"uint256 feeAmount,\\\" +\\n    ///         \\\"string kind,\\\" +\\n    ///         \\\"bool partiallyFillable\\\" +\\n    ///     \\\")\\\"\\n    /// )\\n    /// ```\\n    bytes32 internal constant ORDER_TYPE_HASH =\\n        hex\\\"b2b38b9dcbdeb41f7ad71dea9aed79fb47f7bbc3436576fe994b43d5b16ecdec\\\";\\n\\n    /// @dev A struct representing a trade to be executed as part a batch\\n    /// settlement.\\n    struct Trade {\\n        Order order;\\n        uint8 sellTokenIndex;\\n        uint8 buyTokenIndex;\\n        uint256 executedAmount;\\n        uint16 feeDiscount;\\n        address owner;\\n        bytes orderUid;\\n    }\\n\\n    /// @dev The stride of an encoded trade.\\n    uint256 private constant TRADE_STRIDE = 206;\\n\\n    /// @dev The byte length of an order unique identifier.\\n    uint256 private constant ORDER_UID_LENGTH = 56;\\n\\n    /// @dev A struct representing arbitrary contract interactions.\\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\\n    struct Interaction {\\n        address target;\\n        bytes callData;\\n    }\\n\\n    /// @dev Returns the number of trades encoded in a calldata byte array.\\n    ///\\n    /// This method reverts if the encoded trades are malformed, i.e. the total\\n    /// length is not a multiple of the stride of a single trade.\\n    /// @param encodedTrades The encoded trades.\\n    /// @return count The total number of trades encoded in the specified bytes.\\n    function tradeCount(bytes calldata encodedTrades)\\n        internal\\n        pure\\n        returns (uint256 count)\\n    {\\n        require(\\n            encodedTrades.length % TRADE_STRIDE == 0,\\n            \\\"GPv2: malformed trade data\\\"\\n        );\\n        count = encodedTrades.length / TRADE_STRIDE;\\n    }\\n\\n    /// @dev Returns a calldata slice to an encoded trade at the specified\\n    /// index.\\n    ///\\n    /// Note that this method does not check that the index is within the bounds\\n    /// of the specified encoded trades, as reading calldata out of bounds just\\n    /// produces 0's and will just decode to an invalid trade that will either\\n    /// fail to recover an address or recover a bogus one.\\n    function tradeAtIndex(bytes calldata encodedTrades, uint256 index)\\n        internal\\n        pure\\n        returns (bytes calldata encodedTrade)\\n    {\\n        // NOTE: Use assembly to slice the calldata bytes without generating\\n        // code for bounds checking.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            encodedTrade.offset := add(\\n                encodedTrades.offset,\\n                mul(index, TRADE_STRIDE)\\n            )\\n            encodedTrade.length := TRADE_STRIDE\\n        }\\n    }\\n\\n    /// @dev Decodes a trade with a signed order from calldata into memory.\\n    ///\\n    /// Trades are tightly packed and compress some data such as the order's buy\\n    /// and sell tokens to reduce calldata size and associated gas costs. As\\n    /// such it is not identical to the decoded [`Trade`] and contains the\\n    /// following fields:\\n    ///\\n    /// ```\\n    /// struct EncodedTrade {\\n    ///     uint8 sellTokenIndex;\\n    ///     uint8 buyTokenIndex;\\n    ///     uint256 sellAmount;\\n    ///     uint256 buyAmount;\\n    ///     uint32 validTo;\\n    ///     uint32 appData;\\n    ///     uint256 feeAmount;\\n    ///     uint8 flags;\\n    ///     uint256 executedAmount;\\n    ///     uint16 feeDiscount;\\n    ///     Signature {\\n    ///         bytes32 r;\\n    ///         bytes32 s;\\n    ///         uint8 v;\\n    ///     } signature;\\n    /// }\\n    /// ```\\n    ///\\n    /// Order flags are used to encode additional order parameters such as the\\n    /// kind of order, either a sell or a buy order, as well as whether the\\n    /// order is partially fillable or if it is a \\\"fill-or-kill\\\" order. As the\\n    /// most likely values are fill-or-kill sell orders, the flags are chosen\\n    /// such that `0x00` represents this kind of order. The flags byte uses has\\n    /// the following format:\\n    /// ```\\n    /// bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\\n    /// ----+-----------------------+---+---+\\n    ///     |        unsused        | * | * |\\n    ///                               |   |\\n    ///                               |   +---- order kind bit, 0 for a sell\\n    ///                               |         order and 1 for a buy order\\n    ///                               |\\n    ///                               +-------- order fill bit, 0 for fill-or-\\n    ///                                         kill and 1 for a partially\\n    ///                                         fillable order\\n    /// ```\\n    ///\\n    /// Order signatures support two schemes:\\n    /// - EIP-712 for signing typed data, this is the default scheme that will\\n    ///   be used when recovering the signing address from the signature.\\n    /// - Generic message signature, this scheme will be used **only** if the\\n    ///   `v` signature parameter's most significant bit is set. This is done as\\n    ///   there are only two possible values `v` can have: 27 or 28, which only\\n    ///   take up the lower 5 bits of the `uint8`.\\n    ///\\n    /// @param domainSeparator The domain separator used for signing the order.\\n    /// @param tokens The list of tokens included in the settlement. The token\\n    /// indices in the encoded order parameters map to tokens in this array.\\n    /// @param encodedTrade The trade as encoded calldata bytes.\\n    /// @param trade The memory location to decode trade to.\\n    function decodeTrade(\\n        bytes calldata encodedTrade,\\n        bytes32 domainSeparator,\\n        IERC20[] calldata tokens,\\n        Trade memory trade\\n    ) internal pure {\\n        uint8 sellTokenIndex;\\n        uint8 buyTokenIndex;\\n        uint32 validTo;\\n        uint256 flags;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n\\n        GPv2Encoding.Order memory order = trade.order;\\n\\n        // NOTE: Use assembly to efficiently decode packed data. Memory structs\\n        // in Solidity aren't packed, so the `Order` fields are in order at 32\\n        // byte increments.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // sellTokenIndex = uint8(encodedTrade[0])\\n            sellTokenIndex := shr(248, calldataload(encodedTrade.offset))\\n            // buyTokenIndex = uint8(encodedTrade[1])\\n            buyTokenIndex := shr(248, calldataload(add(encodedTrade.offset, 1)))\\n            // order.sellAmount = uint256(encodedTrade[2:34])\\n            mstore(add(order, 64), calldataload(add(encodedTrade.offset, 2)))\\n            // order.buyAmount = uint256(encodedTrade[34:66])\\n            mstore(add(order, 96), calldataload(add(encodedTrade.offset, 34)))\\n            // order.validTo = uint32(encodedTrade[66:70])\\n            validTo := shr(224, calldataload(add(encodedTrade.offset, 66)))\\n            // order.appData = uint32(encodedTrade[70:74])\\n            mstore(\\n                add(order, 160),\\n                shr(224, calldataload(add(encodedTrade.offset, 70)))\\n            )\\n            // order.feeAmount = uint256(encodedTrade[74:106])\\n            mstore(add(order, 192), calldataload(add(encodedTrade.offset, 74)))\\n            // flags = uint8(encodedTrade[106])\\n            flags := shr(248, calldataload(add(encodedTrade.offset, 106)))\\n            // trade.executedAmount = uint256(encodedTrade[107:139])\\n            mstore(add(trade, 96), calldataload(add(encodedTrade.offset, 107)))\\n            // trade.feeDiscount = uint256(encodedTrade[139:141])\\n            mstore(\\n                add(trade, 128),\\n                shr(240, calldataload(add(encodedTrade.offset, 139)))\\n            )\\n            // r = uint256(encodedTrade[141:173])\\n            r := calldataload(add(encodedTrade.offset, 141))\\n            // s = uint256(encodedTrade[173:205])\\n            s := calldataload(add(encodedTrade.offset, 173))\\n            // v = uint8(encodedTrade[205])\\n            v := shr(248, calldataload(add(encodedTrade.offset, 205)))\\n        }\\n\\n        order.sellToken = tokens[sellTokenIndex];\\n        order.buyToken = tokens[buyTokenIndex];\\n        order.validTo = validTo;\\n        if (flags & 0x01 == 0) {\\n            order.kind = ORDER_KIND_SELL;\\n        } else {\\n            order.kind = ORDER_KIND_BUY;\\n        }\\n        order.partiallyFillable = flags & 0x02 != 0;\\n\\n        trade.sellTokenIndex = sellTokenIndex;\\n        trade.buyTokenIndex = buyTokenIndex;\\n\\n        // NOTE: Compute the EIP-712 order struct hash in place. The hash is\\n        // computed from the order type hash concatenated with the ABI encoded\\n        // order fields for a total of `10 * sizeof(uint) = 320` bytes.\\n        // Fortunately, since Solidity memory structs **are not** packed, they\\n        // are already laid out in memory exactly as is needed to compute the\\n        // struct hash, just requiring the order type hash to be temporarily\\n        // writen to the memory slot coming right before the order data.\\n        bytes32 orderDigest;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let dataStart := sub(mload(trade), 32)\\n            let temp := mload(dataStart)\\n            mstore(dataStart, ORDER_TYPE_HASH)\\n            orderDigest := keccak256(dataStart, 320)\\n            mstore(dataStart, temp)\\n        }\\n\\n        // NOTE: Solidity allocates, but does not free, memory when:\\n        // - calling the ABI encoding methods\\n        // - calling the `ecrecover` precompile.\\n        // However, we can restore the free memory pointer to before we made\\n        // allocations to effectively free the memory. This is safe as the\\n        // memory used can be discarded, and the memory pointed to by the free\\n        // memory pointer **does not have to point to zero-ed out memory**.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\\n        uint256 freeMemoryPointer;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            freeMemoryPointer := mload(0x40)\\n        }\\n\\n        bytes32 signingDigest;\\n        if (v & 0x80 == 0) {\\n            // NOTE: The most significant bit **is not set**, so the order is\\n            // signed using the EIP-712 sheme, the signing hash is of:\\n            // `\\\"\\\\x19\\\\x01\\\" || domainSeparator || orderDigest`.\\n            signingDigest = keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, orderDigest)\\n            );\\n        } else {\\n            // NOTE: The most significant bit **is set**, so the order is signed\\n            // using generic message scheme, the signing hash is of:\\n            // `\\\"\\\\x19Ethereum Signed Message:\\\\n\\\" || length || data` where the\\n            // length is a constant 64 bytes and the data is defined as:\\n            // `domainSeparator || orderDigest`.\\n            signingDigest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n64\\\",\\n                    domainSeparator,\\n                    orderDigest\\n                )\\n            );\\n        }\\n\\n        address owner = ecrecover(signingDigest, v & 0x1f, r, s);\\n        require(owner != address(0), \\\"GPv2: invalid signature\\\");\\n\\n        trade.owner = owner;\\n\\n        // NOTE: Restore the free memory pointer to free temporary memory.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(0x40, freeMemoryPointer)\\n        }\\n\\n        // NOTE: Initialize the memory for the order UID if required.\\n        if (trade.orderUid.length != ORDER_UID_LENGTH) {\\n            trade.orderUid = new bytes(ORDER_UID_LENGTH);\\n        }\\n\\n        // NOTE: Write the order UID to the allocated memory buffer. The order\\n        // parameters are written to memory in **reverse order** as memory\\n        // operations write 32-bytes at a time and we want to use a packed\\n        // encoding. This means, for example, that after writing the value of\\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\\n        // only 20 bytes and `20:32` should be `0`s:\\n        //\\n        //        |           1111111111222222222233333333334444444444555555\\n        //   byte | 01234567890123456789012345678901234567890123456789012345\\n        // -------+---------------------------------------------------------\\n        //  field | [.........orderDigest..........][......owner.......][vT]\\n        // -------+---------------------------------------------------------\\n        // mstore |                         [000000000000000000000000000.vT]\\n        //        |                     [00000000000.......owner.......]\\n        //        | [.........orderDigest..........]\\n        //\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // orderUid = trade.orderUid.dataOffset\\n            let orderUid := add(mload(add(trade, 192)), 32)\\n            mstore(add(orderUid, 24), validTo)\\n            mstore(add(orderUid, 20), owner)\\n            mstore(orderUid, orderDigest)\\n        }\\n    }\\n\\n    /// @dev Decodes an interaction from calldata into memory.\\n    ///\\n    /// An encoded interaction has three components: the target address, the data\\n    /// length, and the actual interaction data of variable size.\\n    ///\\n    /// ```\\n    /// struct EncodedInteraction {\\n    ///     address target;\\n    ///     uint24 dataLength;\\n    ///     bytes callData;\\n    /// }\\n    /// ```\\n    ///\\n    /// All entries are tightly packed together in this order in the encoded\\n    /// calldata. Example:\\n    ///\\n    /// input:    0x73c14081446bd1e4eb165250e826e80c5a523783000010000102030405060708090a0b0c0d0e0f\\n    /// decoding:   [...............target.................][leng][............data..............]\\n    /// stride:                                          20     3    (defined in length field) 16\\n    ///\\n    /// This function enforces that the encoded data stores enough bytes to\\n    /// cover the full length of the decoded interaction.\\n    ///\\n    /// The size of `dataLength` limits the maximum calldata that can be used in\\n    /// an interaction. Based on the current rules of the Ethereum protocol,\\n    /// this length is enough to include any valid transaction: an extra\\n    /// calldata byte costs at least 4 gas, and the maximum gas spent in a block\\n    /// is 12.5M. This gives an upper bound on the calldata that can be included\\n    /// in a block of\\n    ///   3.125.000 < 16.777.216 = 2**(3*8) .\\n    ///\\n    /// @param encodedInteractions The interactions as encoded calldata bytes.\\n    /// @param interaction The memory location to decode the interaction to.\\n    /// @return remainingEncodedInteractions The part of encodedInteractions that\\n    /// has not been decoded after this function is executed.\\n    function decodeInteraction(\\n        bytes calldata encodedInteractions,\\n        Interaction memory interaction\\n    ) internal pure returns (bytes calldata remainingEncodedInteractions) {\\n        uint256 dataLength;\\n\\n        // Note: use assembly to efficiently decode packed data and store the\\n        // target address.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // interaction.target = address(encodedInteractions[0])\\n            mstore(\\n                interaction,\\n                shr(96, calldataload(encodedInteractions.offset))\\n            )\\n\\n            // dataLength = uint24(encodedInteractions[1])\\n            dataLength := shr(\\n                232,\\n                calldataload(add(encodedInteractions.offset, 20))\\n            )\\n        }\\n\\n        // Safety: dataLength fits a uint24, no overflow is possible.\\n        uint256 encodedInteractionSize = 20 + 3 + dataLength;\\n        require(\\n            encodedInteractions.length >= encodedInteractionSize,\\n            \\\"GPv2: invalid interaction\\\"\\n        );\\n\\n        bytes calldata interactionCallData;\\n        // Note: assembly is used to split the calldata into two components, one\\n        // being the calldata of the current interaction and the other being the\\n        // encoded bytes of the remaining interactions.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            interactionCallData.offset := add(encodedInteractions.offset, 23)\\n            interactionCallData.length := dataLength\\n\\n            remainingEncodedInteractions.offset := add(\\n                encodedInteractions.offset,\\n                encodedInteractionSize\\n            )\\n            remainingEncodedInteractions.length := sub(\\n                encodedInteractions.length,\\n                encodedInteractionSize\\n            )\\n        }\\n\\n        // Solidity takes care of copying the calldata slice into memory.\\n        interaction.callData = interactionCallData;\\n    }\\n\\n    /// @dev Extracts specific order information from the standardized unique\\n    /// order id of the protocol.\\n    ///\\n    /// @param orderUid The unique identifier used to represent an order in\\n    /// the protocol. This uid is the packed concatenation of the order digest,\\n    /// the validTo order parameter and the address of the user who created the\\n    /// order. It is used by the user to interface with the contract directly,\\n    /// and not by calls that are triggered by the solvers.\\n    /// @return orderDigest The EIP-712 signing digest derived from the order\\n    /// parameters.\\n    /// @return owner The address of the user who owns this order.\\n    /// @return validTo The epoch time at which the order will stop being valid.\\n    function extractOrderUidParams(bytes calldata orderUid)\\n        internal\\n        pure\\n        returns (\\n            bytes32 orderDigest,\\n            address owner,\\n            uint32 validTo\\n        )\\n    {\\n        require(orderUid.length == 32 + 20 + 4, \\\"GPv2: invalid uid\\\");\\n        // Use assembly to efficiently decode packed calldata.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            orderDigest := calldataload(orderUid.offset)\\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x901c973a0be1817f91438ace2d60882e21c90f29ca9301443130d535b2d7e221\",\"license\":\"LGPL-3.0-or-later\"},\"src/contracts/libraries/GPv2TradeExecution.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Trade Execution\\n/// @author Gnosis Developers\\nlibrary GPv2TradeExecution {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev Ether marker address used to indicate an order is buying Ether.\\n    address internal constant BUY_ETH_ADDRESS =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @dev Executed trade data.\\n    struct Data {\\n        address owner;\\n        IERC20 sellToken;\\n        IERC20 buyToken;\\n        uint256 sellAmount;\\n        uint256 buyAmount;\\n    }\\n\\n    /// @dev Executes the trade's sell amount, transferring it from the trade's\\n    /// owner to the specified recipient.\\n    function transferSellAmountToRecipient(\\n        Data calldata trade,\\n        address recipient\\n    ) internal {\\n        trade.sellToken.safeTransferFrom(\\n            trade.owner,\\n            recipient,\\n            trade.sellAmount\\n        );\\n    }\\n\\n    /// @dev Executes the trade's buy amount, transferring it to the trade's\\n    /// owner from the caller's address.\\n    function transferBuyAmountToOwner(Data memory trade) internal {\\n        if (address(trade.buyToken) == BUY_ETH_ADDRESS) {\\n            payable(trade.owner).transfer(trade.buyAmount);\\n        } else {\\n            trade.buyToken.safeTransfer(trade.owner, trade.buyAmount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x897e317236d30aedbdfda4367eabdd020fc4b4a421e6fdbc89d2806fdf245204\",\"license\":\"LGPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x60e06040523480156200001157600080fd5b50604051620025f0380380620025f083398101604081905262000034916200012f565b6001600160601b0319606082901b1660a0526040514690620000c3907f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f907f6c85c0337eba1661327f94f3bf46c8a7f9311a563f4d5c948362567f5d8ed60c907ff9446b8e937d86f0bc87cac73923491692b123ca5f8761908494703758206adf90859030906020016200015f565b60408051601f19818403018152908290528051602090910120608052620000ea9062000121565b604051809103906000f08015801562000107573d6000803e3d6000fd5b5060601b6001600160601b03191660c052506200018b9050565b6106898062001f6783390190565b60006020828403121562000141578081fd5b81516001600160a01b038116811462000158578182fd5b9392505050565b9485526020850193909352604084019190915260608301526001600160a01b0316608082015260a00190565b60805160a05160601c60c05160601c611d9a620001cd6000398061032e52806103ef5280610f91525080610223525080610413528061053f5250611d9a6000f3fe60806040526004361061005e5760003560e01c80637caf7af0116100435780637caf7af0146100c2578063c4b1e4fb146100e2578063f698da251461010457610065565b806315337bc01461006a5780632479fb6e1461008c57610065565b3661006557005b600080fd5b34801561007657600080fd5b5061008a6100853660046118ab565b610119565b005b34801561009857600080fd5b506100ac6100a73660046118eb565b6101c9565b6040516100b99190611a74565b60405180910390f35b3480156100ce57600080fd5b5061008a6100dd3660046117a0565b6101e6565b3480156100ee57600080fd5b506100f76103ed565b6040516100b991906119ca565b34801561011057600080fd5b506100ac610411565b60006101258383610435565b5091505073ffffffffffffffffffffffffffffffffffffffff81163314610181576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611b0b565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600084846040516101b492919061199e565b90815260405190819003602001902055505050565b805160208183018101805160008252928201919093012091525481565b6040517f02cc250d00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906302cc250d906102589033906004016119ca565b60206040518083038186803b15801561027057600080fd5b505afa158015610284573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a8919061188b565b6102de576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611c55565b60006102ee8b8b8b8b8b8b6104c3565b6040517feaeecbb600000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063eaeecbb6906103639084906004016119eb565b600060405180830381600087803b15801561037d57600080fd5b505af1158015610391573d6000803e3d6000fd5b5050505061039f85856105df565b6103a881610614565b81156103e0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611b42565b5050505050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b60008080603884146104a857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f475076323a20696e76616c696420756964000000000000000000000000000000604482015290519081900360640190fd5b5050823593602084013560601c936034013560e01c92509050565b606060006104d18484610648565b90508067ffffffffffffffff811180156104ea57600080fd5b5060405190808252806020026020018201604052801561052457816020015b610511611640565b8152602001906001900390816105095790505b50915061052f61166e565b60005b828110156105d2576105797f00000000000000000000000000000000000000000000000000000000000000008b8b8561056c8b8b886106c4565b90949093909290916106d2565b6105ca828989856020015160ff1681811061059057fe5b905060200201358a8a866040015160ff168181106105aa57fe5b905060200201358785815181106105bd57fe5b6020026020010151610af2565b600101610532565b5050509695505050505050565b6105e76116b3565b82825b801561060d576105fb828285610eae565b9150915061060883610f8f565b6105ea565b5050505050565b60005b81518110156106445761063c82828151811061062f57fe5b60200260200101516110a2565b600101610617565b5050565b600060ce8206156106ba57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f475076323a206d616c666f726d65642074726164652064617461000000000000604482015290519081900360640190fd5b5060ce9004919050565b60ce90810292909201929050565b8051600287013560408201526022870135606080830191909152604688013560e090811c60a0840152604a89013560c0840152606b89013591840191909152608b88013560f01c6080840152873560f890811c9260018a0135821c9260428b0135901c91606a8b0135811c9160cd8c013590911c90608d8c01359060ad8d0135908a8a8981811061075f57fe5b602002919091013573ffffffffffffffffffffffffffffffffffffffff168252508a8a60ff891681811061078f57fe5b6020908102929092013573ffffffffffffffffffffffffffffffffffffffff16918301919091525063ffffffff86166080820152600185166107f6577ff3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee34677560e082015261081d565b7f6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc60e08201525b60028516151561010082015260ff80891660208b015287166040808b019190915289517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00180517fb2b38b9dcbdeb41f7ad71dea9aed79fb47f7bbc3436576fe994b43d5b16ecdec82526101408220915290516000608087166108f8578e8360405160200180807f190100000000000000000000000000000000000000000000000000000000000081525060020183815260200182815260200192505050604051602081830303815290604052805190602001209050610952565b8e8360405160200180807f19457468657265756d205369676e6564204d6573736167653a0a363400000000815250601c01838152602001828152602001925050506040516020818303038152906040528051906020012090505b6040805160008082526020808301808552859052601f8b1683850152606083018a9052608083018990529251909260019260a0808201937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081019281900390910190855afa1580156109c8573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116610a7557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f475076323a20696e76616c6964207369676e6174757265000000000000000000604482015290519081900360640190fd5b73ffffffffffffffffffffffffffffffffffffffff811660a08e0152604083905260c08d015151603814610ac657604080516038808252606082019092529060208201818036833750505060c08e01525b602060c08e0151018a601882015281601482015284815250505050505050505050505050505050505050565b835160808101514263ffffffff9091161015610b3a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611b79565b60a085015173ffffffffffffffffffffffffffffffffffffffff9081168352815181166020808501919091528201511660408301526060810151610b7e9084611159565b6040820151610b8d9086611159565b1015610bc5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611bb0565b6000806000807ff3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee3467758560e001511415610ccb5784610100015115610c3457886060015193508460400151610c25858760c0015161115990919063ffffffff16565b81610c2c57fe5b049150610c43565b846040015193508460c0015191505b86610c4e858a611159565b81610c5557fe5b049250610c868460008b60c00151604051610c7091906119ae565b90815260405190819003602001902054906111d5565b90508460400151811115610cc6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611c1e565b610d84565b84610100015115610d0857886060015192508460600151610cf9848760c0015161115990919063ffffffff16565b81610d0057fe5b049150610d17565b846060015192508460c0015191505b87610d228489611159565b81610d2957fe5b049350610d448360008b60c00151604051610c7091906119ae565b90508460600151811115610d84576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611c1e565b612710896080015161ffff161115610dc8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611be7565b612710610dea8a6080015161ffff16612710038461115990919063ffffffff16565b81610df157fe5b049150610dfe84836111d5565b60608701526080860183905260c08901516040518291600091610e2191906119ae565b908152602001604051809103902081905550856000015173ffffffffffffffffffffffffffffffffffffffff167fa07a543ab8a018198e99ca0184c93fe9050a79400a0a723441f84de1d972cc178760200151886040015189606001518a60800151878f60c00151604051610e9b96959493929190611a7d565b60405180910390a2505050505050505050565b823560601c8152366000601485013560e81c6017810180861015610f3357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f475076323a20696e76616c696420696e746572616374696f6e00000000000000604482015290519081900360640190fd5b604080516020601f85018190048102820181019092528381528289019550828803945060178901918491908390839081908401838280828437600092019190915250505050602090970196909652509296919550909350505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16816000015173ffffffffffffffffffffffffffffffffffffffff161415611019576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611c8c565b600080826000015173ffffffffffffffffffffffffffffffffffffffff16836020015160405161104991906119ae565b6000604051808303816000865af19150503d8060008114611086576040519150601f19603f3d011682016040523d82523d6000602084013e61108b565b606091505b50915091508161109d57805160208201fd5b505050565b604081015173ffffffffffffffffffffffffffffffffffffffff1673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1415611128578051608082015160405173ffffffffffffffffffffffffffffffffffffffff9092169181156108fc0291906000818181858888f19350505050158015611122573d6000803e3d6000fd5b50611156565b8051608082015160408301516111569273ffffffffffffffffffffffffffffffffffffffff90911691611249565b50565b600082611168575060006111cf565b8282028284828161117557fe5b04146111cc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526021815260200180611d1a6021913960400191505060405180910390fd5b90505b92915050565b6000828201838110156111cc57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b6040805173ffffffffffffffffffffffffffffffffffffffff8416602482015260448082018490528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb0000000000000000000000000000000000000000000000000000000017905261109d9084906000611333826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff166113a99092919063ffffffff16565b80519091501561109d5780806020019051602081101561135257600080fd5b505161109d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a815260200180611d3b602a913960400191505060405180910390fd5b60606113b884846000856113c2565b90505b9392505050565b60608247101561141d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526026815260200180611cf46026913960400191505060405180910390fd5b6114268561157c565b61149157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015290519081900360640190fd5b6000808673ffffffffffffffffffffffffffffffffffffffff1685876040518082805190602001908083835b602083106114fa57805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016114bd565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d806000811461155c576040519150601f19603f3d011682016040523d82523d6000602084013e611561565b606091505b5091509150611571828286611582565b979650505050505050565b3b151590565b606083156115915750816113bb565b8251156115a15782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360005b838110156116055781810151838201526020016115ed565b50505050905090810190601f1680156116325780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915290565b6040518060e001604052806116816116cb565b81526000602082018190526040820181905260608083018290526080830182905260a083019190915260c09091015290565b60408051808201909152600081526060602082015290565b6040805161012081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905261010081019190915290565b60008083601f840112611728578081fd5b50813567ffffffffffffffff81111561173f578182fd5b602083019150836020808302850101111561175957600080fd5b9250929050565b60008083601f840112611771578182fd5b50813567ffffffffffffffff811115611788578182fd5b60208301915083602082850101111561175957600080fd5b60008060008060008060008060008060a08b8d0312156117be578586fd5b8a3567ffffffffffffffff808211156117d5578788fd5b6117e18e838f01611717565b909c509a5060208d01359150808211156117f9578788fd5b6118058e838f01611717565b909a50985060408d013591508082111561181d578788fd5b6118298e838f01611760565b909850965060608d0135915080821115611841578586fd5b61184d8e838f01611760565b909650945060808d0135915080821115611865578384fd5b506118728d828e01611760565b915080935050809150509295989b9194979a5092959850565b60006020828403121561189c578081fd5b815180151581146111cc578182fd5b600080602083850312156118bd578182fd5b823567ffffffffffffffff8111156118d3578283fd5b6118df85828601611760565b90969095509350505050565b600060208083850312156118fd578182fd5b823567ffffffffffffffff80821115611914578384fd5b818501915085601f830112611927578384fd5b81358181111561193357fe5b604051847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116820101818110848211171561196e57fe5b6040528181528382018501881015611984578586fd5b818585018683013790810190930193909352509392505050565b6000828483379101908152919050565b600082516119c0818460208701611cc3565b9190910192915050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b602080825282518282018190526000919060409081850190868401855b82811015611a67578151805173ffffffffffffffffffffffffffffffffffffffff908116865287820151811688870152868201511686860152606080820151908601526080908101519085015260a09093019290850190600101611a08565b5091979650505050505050565b90815260200190565b600073ffffffffffffffffffffffffffffffffffffffff808916835280881660208401525085604083015284606083015283608083015260c060a083015282518060c0840152611ad48160e0850160208701611cc3565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160e001979650505050505050565b6020808252601f908201527f475076323a2063616c6c657220646f6573206e6f74206f776e206f7264657200604082015260600190565b60208082526013908201527f6e6f742079657420696d706c656d656e74656400000000000000000000000000604082015260600190565b60208082526013908201527f475076323a206f72646572206578706972656400000000000000000000000000604082015260600190565b6020808252601f908201527f475076323a206c696d6974207072696365206e6f742072657370656374656400604082015260600190565b6020808252601a908201527f475076323a20696e76616c69642066656520646973636f756e74000000000000604082015260600190565b60208082526012908201527f475076323a206f726465722066696c6c65640000000000000000000000000000604082015260600190565b60208082526012908201527f475076323a206e6f74206120736f6c7665720000000000000000000000000000604082015260600190565b6020808252601b908201527f475076323a20666f7262696464656e20696e746572616374696f6e0000000000604082015260600190565b60005b83811015611cde578181015183820152602001611cc6565b83811115611ced576000848401525b5050505056fe416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775361666545524332303a204552433230206f7065726174696f6e20646964206e6f742073756363656564a2646970667358221220d2a72d1d9048827982a78783455cb48b31b819d0fa7ce82a847eb483b541637364736f6c6343000706003360a060405234801561001057600080fd5b5033606081901b60805261065961003060003980605d52506106596000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063eaeecbb614610030575b600080fd5b61004361003e36600461052c565b610045565b005b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146100bd576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100b49061059c565b60405180910390fd5b60005b818110156100eb576100e38383838181106100d757fe5b905060a00201336100f0565b6001016100c0565b505050565b61011e73ffffffffffffffffffffffffffffffffffffffff6020840135811690843516836060860135610122565b5050565b6040805173ffffffffffffffffffffffffffffffffffffffff80861660248301528416604482015260648082018490528251808303909101815260849091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd000000000000000000000000000000000000000000000000000000001790526101b79085906101bd565b50505050565b600061021f826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff166102959092919063ffffffff16565b8051909150156100eb5780806020019051602081101561023e57600080fd5b50516100eb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a8152602001806105fa602a913960400191505060405180910390fd5b60606102a484846000856102ae565b90505b9392505050565b606082471015610309576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001806105d46026913960400191505060405180910390fd5b61031285610468565b61037d57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015290519081900360640190fd5b6000808673ffffffffffffffffffffffffffffffffffffffff1685876040518082805190602001908083835b602083106103e657805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016103a9565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d8060008114610448576040519150601f19603f3d011682016040523d82523d6000602084013e61044d565b606091505b509150915061045d82828661046e565b979650505050505050565b3b151590565b6060831561047d5750816102a7565b82511561048d5782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360005b838110156104f15781810151838201526020016104d9565b50505050905090810190601f16801561051e5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b6000806020838503121561053e578182fd5b823567ffffffffffffffff80821115610555578384fd5b818501915085601f830112610568578384fd5b813581811115610576578485fd5b86602060a08302850101111561058a578485fd5b60209290920196919550909350505050565b6020808252601d908201527f475076323a206e6f7420616c6c6f77616e636520726563697069656e7400000060408201526060019056fe416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c6c5361666545524332303a204552433230206f7065726174696f6e20646964206e6f742073756363656564a264697066735822122082c8a90e42d848dc453d40636dcab750cb813942c59794beb05101c72f6a6ccf64736f6c63430007060033",
  "deployedBytecode": "0x60806040526004361061005e5760003560e01c80637caf7af0116100435780637caf7af0146100c2578063c4b1e4fb146100e2578063f698da251461010457610065565b806315337bc01461006a5780632479fb6e1461008c57610065565b3661006557005b600080fd5b34801561007657600080fd5b5061008a6100853660046118ab565b610119565b005b34801561009857600080fd5b506100ac6100a73660046118eb565b6101c9565b6040516100b99190611a74565b60405180910390f35b3480156100ce57600080fd5b5061008a6100dd3660046117a0565b6101e6565b3480156100ee57600080fd5b506100f76103ed565b6040516100b991906119ca565b34801561011057600080fd5b506100ac610411565b60006101258383610435565b5091505073ffffffffffffffffffffffffffffffffffffffff81163314610181576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611b0b565b60405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600084846040516101b492919061199e565b90815260405190819003602001902055505050565b805160208183018101805160008252928201919093012091525481565b6040517f02cc250d00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906302cc250d906102589033906004016119ca565b60206040518083038186803b15801561027057600080fd5b505afa158015610284573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a8919061188b565b6102de576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611c55565b60006102ee8b8b8b8b8b8b6104c3565b6040517feaeecbb600000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063eaeecbb6906103639084906004016119eb565b600060405180830381600087803b15801561037d57600080fd5b505af1158015610391573d6000803e3d6000fd5b5050505061039f85856105df565b6103a881610614565b81156103e0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611b42565b5050505050505050505050565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b60008080603884146104a857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f475076323a20696e76616c696420756964000000000000000000000000000000604482015290519081900360640190fd5b5050823593602084013560601c936034013560e01c92509050565b606060006104d18484610648565b90508067ffffffffffffffff811180156104ea57600080fd5b5060405190808252806020026020018201604052801561052457816020015b610511611640565b8152602001906001900390816105095790505b50915061052f61166e565b60005b828110156105d2576105797f00000000000000000000000000000000000000000000000000000000000000008b8b8561056c8b8b886106c4565b90949093909290916106d2565b6105ca828989856020015160ff1681811061059057fe5b905060200201358a8a866040015160ff168181106105aa57fe5b905060200201358785815181106105bd57fe5b6020026020010151610af2565b600101610532565b5050509695505050505050565b6105e76116b3565b82825b801561060d576105fb828285610eae565b9150915061060883610f8f565b6105ea565b5050505050565b60005b81518110156106445761063c82828151811061062f57fe5b60200260200101516110a2565b600101610617565b5050565b600060ce8206156106ba57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f475076323a206d616c666f726d65642074726164652064617461000000000000604482015290519081900360640190fd5b5060ce9004919050565b60ce90810292909201929050565b8051600287013560408201526022870135606080830191909152604688013560e090811c60a0840152604a89013560c0840152606b89013591840191909152608b88013560f01c6080840152873560f890811c9260018a0135821c9260428b0135901c91606a8b0135811c9160cd8c013590911c90608d8c01359060ad8d0135908a8a8981811061075f57fe5b602002919091013573ffffffffffffffffffffffffffffffffffffffff168252508a8a60ff891681811061078f57fe5b6020908102929092013573ffffffffffffffffffffffffffffffffffffffff16918301919091525063ffffffff86166080820152600185166107f6577ff3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee34677560e082015261081d565b7f6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc60e08201525b60028516151561010082015260ff80891660208b015287166040808b019190915289517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00180517fb2b38b9dcbdeb41f7ad71dea9aed79fb47f7bbc3436576fe994b43d5b16ecdec82526101408220915290516000608087166108f8578e8360405160200180807f190100000000000000000000000000000000000000000000000000000000000081525060020183815260200182815260200192505050604051602081830303815290604052805190602001209050610952565b8e8360405160200180807f19457468657265756d205369676e6564204d6573736167653a0a363400000000815250601c01838152602001828152602001925050506040516020818303038152906040528051906020012090505b6040805160008082526020808301808552859052601f8b1683850152606083018a9052608083018990529251909260019260a0808201937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081019281900390910190855afa1580156109c8573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116610a7557604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f475076323a20696e76616c6964207369676e6174757265000000000000000000604482015290519081900360640190fd5b73ffffffffffffffffffffffffffffffffffffffff811660a08e0152604083905260c08d015151603814610ac657604080516038808252606082019092529060208201818036833750505060c08e01525b602060c08e0151018a601882015281601482015284815250505050505050505050505050505050505050565b835160808101514263ffffffff9091161015610b3a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611b79565b60a085015173ffffffffffffffffffffffffffffffffffffffff9081168352815181166020808501919091528201511660408301526060810151610b7e9084611159565b6040820151610b8d9086611159565b1015610bc5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611bb0565b6000806000807ff3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee3467758560e001511415610ccb5784610100015115610c3457886060015193508460400151610c25858760c0015161115990919063ffffffff16565b81610c2c57fe5b049150610c43565b846040015193508460c0015191505b86610c4e858a611159565b81610c5557fe5b049250610c868460008b60c00151604051610c7091906119ae565b90815260405190819003602001902054906111d5565b90508460400151811115610cc6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611c1e565b610d84565b84610100015115610d0857886060015192508460600151610cf9848760c0015161115990919063ffffffff16565b81610d0057fe5b049150610d17565b846060015192508460c0015191505b87610d228489611159565b81610d2957fe5b049350610d448360008b60c00151604051610c7091906119ae565b90508460600151811115610d84576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611c1e565b612710896080015161ffff161115610dc8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611be7565b612710610dea8a6080015161ffff16612710038461115990919063ffffffff16565b81610df157fe5b049150610dfe84836111d5565b60608701526080860183905260c08901516040518291600091610e2191906119ae565b908152602001604051809103902081905550856000015173ffffffffffffffffffffffffffffffffffffffff167fa07a543ab8a018198e99ca0184c93fe9050a79400a0a723441f84de1d972cc178760200151886040015189606001518a60800151878f60c00151604051610e9b96959493929190611a7d565b60405180910390a2505050505050505050565b823560601c8152366000601485013560e81c6017810180861015610f3357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f475076323a20696e76616c696420696e746572616374696f6e00000000000000604482015290519081900360640190fd5b604080516020601f85018190048102820181019092528381528289019550828803945060178901918491908390839081908401838280828437600092019190915250505050602090970196909652509296919550909350505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16816000015173ffffffffffffffffffffffffffffffffffffffff161415611019576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161017890611c8c565b600080826000015173ffffffffffffffffffffffffffffffffffffffff16836020015160405161104991906119ae565b6000604051808303816000865af19150503d8060008114611086576040519150601f19603f3d011682016040523d82523d6000602084013e61108b565b606091505b50915091508161109d57805160208201fd5b505050565b604081015173ffffffffffffffffffffffffffffffffffffffff1673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee1415611128578051608082015160405173ffffffffffffffffffffffffffffffffffffffff9092169181156108fc0291906000818181858888f19350505050158015611122573d6000803e3d6000fd5b50611156565b8051608082015160408301516111569273ffffffffffffffffffffffffffffffffffffffff90911691611249565b50565b600082611168575060006111cf565b8282028284828161117557fe5b04146111cc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526021815260200180611d1a6021913960400191505060405180910390fd5b90505b92915050565b6000828201838110156111cc57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b6040805173ffffffffffffffffffffffffffffffffffffffff8416602482015260448082018490528251808303909101815260649091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb0000000000000000000000000000000000000000000000000000000017905261109d9084906000611333826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff166113a99092919063ffffffff16565b80519091501561109d5780806020019051602081101561135257600080fd5b505161109d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a815260200180611d3b602a913960400191505060405180910390fd5b60606113b884846000856113c2565b90505b9392505050565b60608247101561141d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526026815260200180611cf46026913960400191505060405180910390fd5b6114268561157c565b61149157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015290519081900360640190fd5b6000808673ffffffffffffffffffffffffffffffffffffffff1685876040518082805190602001908083835b602083106114fa57805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016114bd565b6001836020036101000a03801982511681845116808217855250505050505090500191505060006040518083038185875af1925050503d806000811461155c576040519150601f19603f3d011682016040523d82523d6000602084013e611561565b606091505b5091509150611571828286611582565b979650505050505050565b3b151590565b606083156115915750816113bb565b8251156115a15782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360005b838110156116055781810151838201526020016115ed565b50505050905090810190601f1680156116325780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915290565b6040518060e001604052806116816116cb565b81526000602082018190526040820181905260608083018290526080830182905260a083019190915260c09091015290565b60408051808201909152600081526060602082015290565b6040805161012081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e0810182905261010081019190915290565b60008083601f840112611728578081fd5b50813567ffffffffffffffff81111561173f578182fd5b602083019150836020808302850101111561175957600080fd5b9250929050565b60008083601f840112611771578182fd5b50813567ffffffffffffffff811115611788578182fd5b60208301915083602082850101111561175957600080fd5b60008060008060008060008060008060a08b8d0312156117be578586fd5b8a3567ffffffffffffffff808211156117d5578788fd5b6117e18e838f01611717565b909c509a5060208d01359150808211156117f9578788fd5b6118058e838f01611717565b909a50985060408d013591508082111561181d578788fd5b6118298e838f01611760565b909850965060608d0135915080821115611841578586fd5b61184d8e838f01611760565b909650945060808d0135915080821115611865578384fd5b506118728d828e01611760565b915080935050809150509295989b9194979a5092959850565b60006020828403121561189c578081fd5b815180151581146111cc578182fd5b600080602083850312156118bd578182fd5b823567ffffffffffffffff8111156118d3578283fd5b6118df85828601611760565b90969095509350505050565b600060208083850312156118fd578182fd5b823567ffffffffffffffff80821115611914578384fd5b818501915085601f830112611927578384fd5b81358181111561193357fe5b604051847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116820101818110848211171561196e57fe5b6040528181528382018501881015611984578586fd5b818585018683013790810190930193909352509392505050565b6000828483379101908152919050565b600082516119c0818460208701611cc3565b9190910192915050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b602080825282518282018190526000919060409081850190868401855b82811015611a67578151805173ffffffffffffffffffffffffffffffffffffffff908116865287820151811688870152868201511686860152606080820151908601526080908101519085015260a09093019290850190600101611a08565b5091979650505050505050565b90815260200190565b600073ffffffffffffffffffffffffffffffffffffffff808916835280881660208401525085604083015284606083015283608083015260c060a083015282518060c0840152611ad48160e0850160208701611cc3565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169190910160e001979650505050505050565b6020808252601f908201527f475076323a2063616c6c657220646f6573206e6f74206f776e206f7264657200604082015260600190565b60208082526013908201527f6e6f742079657420696d706c656d656e74656400000000000000000000000000604082015260600190565b60208082526013908201527f475076323a206f72646572206578706972656400000000000000000000000000604082015260600190565b6020808252601f908201527f475076323a206c696d6974207072696365206e6f742072657370656374656400604082015260600190565b6020808252601a908201527f475076323a20696e76616c69642066656520646973636f756e74000000000000604082015260600190565b60208082526012908201527f475076323a206f726465722066696c6c65640000000000000000000000000000604082015260600190565b60208082526012908201527f475076323a206e6f74206120736f6c7665720000000000000000000000000000604082015260600190565b6020808252601b908201527f475076323a20666f7262696464656e20696e746572616374696f6e0000000000604082015260600190565b60005b83811015611cde578181015183820152602001611cc6565b83811115611ced576000848401525b5050505056fe416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775361666545524332303a204552433230206f7065726174696f6e20646964206e6f742073756363656564a2646970667358221220d2a72d1d9048827982a78783455cb48b31b819d0fa7ce82a847eb483b541637364736f6c63430007060033",
  "devdoc": {
    "author": "Gnosis Developers",
    "events": {
      "Trade(address,address,address,uint256,uint256,uint256,bytes)": {
        "details": "Event emitted for each executed trade."
      }
    },
    "kind": "dev",
    "methods": {
      "invalidateOrder(bytes)": {
        "details": "Invalidate onchain an order that has been signed offline.",
        "params": {
          "orderUid": "The unique identifier of the order that is to be made invalid after calling this function. The user that created the order must be the the sender of this message. See [`extractOrderUidParams`] for details on orderUid."
        }
      },
      "settle(address[],uint256[],bytes,bytes,bytes)": {
        "details": "Settle the specified orders at a clearing price. Note that it is the responsibility of the caller to ensure that all GPv2 invariants are upheld for the input settlement, otherwise this call will revert. Namely: - The fee factor cannot lead to fees > 0.1% - All orders are valid and signed - Accounts have sufficient balance and approval. - Settlement contract has sufficient balance to execute trades. Note   this implies that the accumulated fees held in the contract can also   be used for settlement. This is OK since:   - Solvers need to be authorized   - Misbehaving solvers will be slashed for abusing accumulated fees for     settlement   - Critically, user orders are entirely protected Note that some parameters are encoded as packed bytes in order to save calldata gas. For more information on encoding format consult the [`GPv2Encoding`] library.",
        "params": {
          "clearingPrices": "An array of clearing prices where the `i`-th price is for the `i`-th token in the [`tokens`] array.",
          "encodedInteractions": "Encoded smart contract interactions.",
          "encodedOrderRefunds": "Encoded order refunds for clearing storage related to invalid orders.",
          "encodedTrades": "Encoded trades for signed EOA orders.",
          "tokens": "An array of ERC20 tokens to be traded in the settlement. Orders and interactions encode tokens as indices into this array."
        }
      }
    },
    "stateVariables": {
      "BPS_BASE": {
        "details": "The number of basis points to make up 100%."
      },
      "DOMAIN_NAME": {
        "details": "The EIP-712 domain name used for computing the domain separator."
      },
      "DOMAIN_TYPE_HASH": {
        "details": "The EIP-712 domain type hash used for computing the domain separator."
      },
      "DOMAIN_VERSION": {
        "details": "The EIP-712 domain version used for computing the domain separator."
      },
      "allowanceManager": {
        "details": "The allowance manager which has access to EOA order funds. This contract is created during deployment"
      },
      "authenticator": {
        "details": "The authenticator is used to determine who can call the settle function. That is, only authorised solvers have the ability to invoke settlements. Any valid authenticator implements an isSolver method called by the onlySolver modifier below."
      },
      "domainSeparator": {
        "details": "The domain separator used for signing orders that gets mixed in making signatures for different domains incompatible. This domain separator is computed following the EIP-712 standard and has replay protection mixed in so that signed orders are only valid for specific GPv2 contracts."
      },
      "filledAmount": {
        "details": "Map each user order by UID to the amount that has been filled so far. If this amount is larger than or equal to the amount traded in the order (amount sold for sell orders, amount bought for buy orders) then the order cannot be traded anymore. If the order is fill or kill, then this value is only used to determine whether the order has already been executed."
      }
    },
    "title": "Gnosis Protocol v2 Settlement Contract",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1700,
        "contract": "src/contracts/GPv2Settlement.sol:GPv2Settlement",
        "label": "filledAmount",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes_memory_ptr,t_uint256)"
      }
    ],
    "types": {
      "t_bytes_memory_ptr": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes_memory_ptr,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes_memory_ptr",
        "label": "mapping(bytes => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}